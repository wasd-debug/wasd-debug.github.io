<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/lib/animate-css/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"8.0.0-rc.4","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="凉介&#39;s personal blog">
<meta property="og:url" content="http://yoursite.com/page/7/index.html">
<meta property="og:site_name" content="凉介&#39;s personal blog">
<meta property="og:locale" content="zh">
<meta property="article:author" content="Jian Shengnan">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/7/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh'
  };
</script>

  <title>凉介's personal blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">凉介's personal blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jian Shengnan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">67</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content index posts-expand">
          
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/03/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-%E7%AC%AC%E5%90%88%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jian Shengnan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="凉介's personal blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/03/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-%E7%AC%AC%E5%90%88%E8%AE%BA/" class="post-title-link" itemprop="url">第合论知识总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-07-03 00:00:00 / Modified: 17:21:14" itemprop="dateCreated datePublished" datetime="2020-07-03T00:00:00+08:00">2020-07-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="第合论"><a href="#第合论" class="headerlink" title="第合论"></a>第合论</h2><h3 id="集合与关系"><a href="#集合与关系" class="headerlink" title="集合与关系"></a>集合与关系</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ol>
<li><p>==集合==：一些对象的整体就称为一个集合，这个整体的每个对象称为该集合的一个元素。用大写字母表示集合，小写字母表示元素。集合中的元素是无序的不重复的。</p>
</li>
<li><p>集合的表示方法：列举法，叙述法，枚举法，文氏图</p>
</li>
<li><p>==子集==：设AB是任何两个集合，假如A的每一个元素都是B的成员，则称A为B的子集，、逼格额A包含于B内，或者B包含A，记为A$\subseteq $B.如果集合A的每一个元素都属于B。但集合B中至少有一个元素不属于A，则称A为B的真子集，即A$\subset$B，且A不等于B，记为A$\neq$B。</p>
</li>
<li><p>==基数==：集合中元素的个数</p>
</li>
<li><p>子集个数：$2^{n}$</p>
</li>
<li><p>==平凡子集==：集合本身和空集。</p>
</li>
<li><p>==集合相等==：两个集合A和B相等，当且仅当它们具有相同的元素，记为A=B，即a属于集合A当且仅当a属于集合B。集合相等的充要条件是两个集合互为子集。</p>
</li>
<li><p>==空集==：不包含任何元素的集合，记为$\emptyset$</p>
<ul>
<li>空集是任何集合的子集</li>
</ul>
</li>
<li><p>==全集==：在一定范围内，如果所有的集合均为某一集合的子集，则称该集合为全集。</p>
</li>
<li><p>==补集==：集合A的补集记为~A，是那些不属于集合A的元素构成的集合。通常是是存在一个全集的情况下讨论</p>
</li>
<li><p>==幂集==：集合A的幂集，记为P（A），是A所有子集所构成的集合。</p>
</li>
<li><p>==序偶==：由两个元素x，y按照一定的次序组成的二元组称为有序偶对（序偶），记作&lt;x,y&gt;，其中x为第一个元素，y是第二个元素。序偶常常表达两个客体之间的关系。</p>
</li>
<li><p>==n重有序组==（n元组）：由你个元素按照一定的次序组成的n元组称为n重有序组，记作&lt;a1,a2,….,an&gt;。</p>
</li>
<li><p>==笛卡尔积==：设AB是两个集合，若序偶的第一个成员是A的元素，第二个成员是B的元素，所有这样的序偶的集合叫做A和B的笛卡尔积或者直积，记作A$\times$B</p>
</li>
<li><p>==关系==：AB为非空集合称A$\times$B的任意子集R为从A到B的一个二元关系，简称关系，A为R的前域，B为R的后域。A=B，称R是A上的一个二元关系。若&lt;x,y&gt;$\in$R，记为xRy，读作x对y有关系R。由A到B的关系共有$2^{|A|\times|B|}$个</p>
</li>
<li><p>特殊关系：==全域关系==：A$\times$B，空关系，==恒等关系==：设Ix是X上的二元关系且满足Ix = {&lt;x,x&gt;|x$\in$X}，则称Ix是X上的恒等关系。</p>
</li>
<li><p>==定义域和值域==：设R是从A到B的二元关系，C={x|x$\in$A,$\exist$y$\in$B,&lt;x,y&gt;$\in$R}第一位置出现的所有元素为定义域，记为C=domR.第二位置出现的所有元素为值域，记为D=ranR。域fldR=domR$\cup $ranR</p>
</li>
<li><p>==闭包==：设R是X上的二元关系，如果另一个关系R‘满足：</p>
<ol>
<li><p>R’是自反（对称，传递）</p>
</li>
<li><p>R$\subseteq $R’</p>
</li>
<li><p>对于A上的、forall自反的（对称的，传递的）关系R‘’,若R$\subseteq $R’‘,则R‘$\subseteq $R’‘</p>
<p>则称R’是R的自反（对称，传递）闭包。</p>
<p>换句话说，R的自反闭包是包含R的最小的自反的关系。通常用r(R),s(r),t(R)表示R的自反，对称，传递闭包</p>
</li>
</ol>
</li>
<li><p>==集合的划分和覆盖==：设A是一个集合，A1，……Am是A的任何m个非空子集，如果它们满足：</p>
<ul>
<li>它们的并集=A则称集合{A1，…，Am}为A的一个==覆盖==</li>
<li>对一切的i$\neq$j,都有$A_{i}\cap A_{j}=\emptyset $则称集合{A1，…，Am}为集合A的一个==划分==，A1，…Am叫做这个划分的==块==</li>
<li>若{A1,A2,…,Ar}、并为大哥{B1，…，Bs}是同一集合A的两种划分，则其中所有Ai$\cap $Bj$\neq \emptyset $组成的集合称为原来两种划分的==交叉划分==。</li>
<li>给定X的、forall两个划分，若对于每个$A_{}i均有B_{k}$,使$A_{i}\subseteq B_{k}$,z则{A1,…,Ar}称为是{b1,b2,…,Bs}的==加细==</li>
</ul>
</li>
<li><p>==等价关系==：设R是定义在集合A上的关系，如果R是自反的，对称的，传递的，则称关系R为A上的等价关系。</p>
</li>
<li><p>==等价类==：设R是集合A上的等价关系，对任意x$\in$A，称集合[x]$_{R}$:</p>
<p>$[x]_{R}={y|(y\in A)\land (&lt;x,y&gt;\in R)}$</p>
<p>为x关于R的等价类，或者叫作由x生产的一个R的等价类。其中x称为[x]$_{R}$的生成元。</p>
</li>
<li><p>==商集==：设R是集合A上的等价关系，由R确定的一切等价类的集合，称为集合A上的关于R的商集，记为A/R。</p>
</li>
<li><p>等价和划分之间的关系：设R是集合A上的等价关系，则此关系R可唯一的确定一个划分，此划分正好是集合A上关于R的商集。</p>
<p><img src="https://i.loli.net/2020/06/21/JwFLhblQS7Zv2q5.png" alt=""></p>
<p><img src="https://i.loli.net/2020/06/21/2mlWJ65gzdrEatf.png" alt=""></p>
</li>
<li><p>==相容关系==：设R是定义在集合A上的关系，如果R是自反的、对称的，则称此关系R为A上的相容关系。</p>
</li>
<li><p>设r是集合A上的相容关系，如C$\subseteq $A，如果对于C中任何两个元素a1和a2都有a1Ra2，称C是由相容关系R产生的==相容类==。</p>
</li>
<li><p>设R是集合A上的相容关系，不能真包含在任何其他相容类中的相容类，称作==最大相容类==，记作Cr</p>
<p><img src="https://i.loli.net/2020/06/21/YHEik1CvJbDTy2q.png" alt=""></p>
</li>
<li><p>==偏序关系==：R是A上的二元关系，如果R满足：自反，反对称，传递。则称R是A上的偏序关系，记作$\leq$</p>
</li>
<li><p>==偏序集==：集合A连同A上的偏序关系R一起成为一个偏序集，记为&lt;A,R&gt;</p>
</li>
<li><p>==可比==：设&lt;A,$\leq$&gt;是偏序集，x,y$\in$A，若有x$\leq y\lor y\leq x$则称x、并为大哥y是可比的</p>
</li>
<li><p>若xy可比，且$x\leq y和x\ne y$，但不存在z$\in$A，使得$x\leq z\land z\leq y$，则称==y盖住x==。</p>
</li>
<li><p>哈斯图的画法：<img src="https://i.loli.net/2020/06/21/dKhDyiEnfpXGxoB.png" alt=""></p>
</li>
<li><p>设&lt;A,$\leq$&gt;是偏序集，$B \subseteq A$,若B中的每两个元素都有关系，则称B为==链==，若B中的每两个元素都无关，则称B为==反链==。</p>
</li>
<li><p>==全序关系==：设&lt;A,$\leq$&gt;为偏序集，若A是一个链，则称$\leq$为A上的全序关系，此时称&lt;A,$\leq$&gt;为全序集。也就是集合A中任意的两个元素都有关系。</p>
</li>
<li><p>==良序关系==：设&lt;A,$\leq$&gt;是一偏序集，若A的任何一个非空子集都有最小元素，则称“$\leq$”为良序关系，&lt;A,$\leq$&gt;是良序集</p>
</li>
<li><p>良序集是全序集。全序集未必是良序集。有限的全序集是良序集</p>
</li>
<li><p>==函数==：设X和Y是任意两个集合，而f是X到Y的一个二元关系，如果对于每一个x$\in$X，有唯一的y$\in$Y,使得&lt;x,y&gt;$\in$f,则称f是从X到Y的一个函数关系（映射）,记为f:X$\rightarrow$Y。若&lt;x,y&gt;$\in$f,通常y记为f(x)，称x为==自由变元==，称y为x在函数f下的==象==</p>
</li>
<li><p>定义域就是前面有的，值域就是后边有的。说的这么复杂，靠。</p>
</li>
<li><p>从A到B的一切函数构成的集合记为$B^{A}$</p>
</li>
<li><p>函数和关系的差别：函数是一种特殊的关系，它与一般关系比较有如下差别：</p>
<ul>
<li>$A\times B$的任何一个、素白色特权，都是A到B的二元关系，因此，从A到B的不同关系有$2^{|A|\times|B|}$个；但是从A到B的不同的函数却仅有$|B|^{|A|}$个</li>
<li>函数的定义域是X，而不能是X的某个真子集</li>
<li>每个函数中的序偶的第一个元素一定是互补相同的</li>
</ul>
</li>
<li><p>特殊函数：</p>
<p>设f是从A到B的函数，若f满足：</p>
<ul>
<li>ranf=B，则称f为从A到B的==满射==。</li>
<li>若对任意x1,x2$\in$A，且x1不等于x2，则f(x1)$\neq$f(x2)，则称f为从A到B的==单射==</li>
<li>若f既是从A到B的满射，又是单射，则称f为从A到B的==双射==。</li>
<li>设f是A到B的双射，则称B$\rightarrow$A的双射f$^{c}$为f的==逆函数==，记作$f^{-1}$</li>
<li>设函数f：X$\rightarrow$Y,g:W$\rightarrow$Z,若f(X)$\subseteq $W,则$g\circ f={&lt;x,z&gt;|x\in X\land z\in Z\land (\exist y)(y\in Y \land y=f(x) \land z=g(y))}$称g在f的左边可复合。当函数$g\circ f$作用于X中的任意一个元素x时，可记为$g\circ f(x)=g(f(x))$.</li>
<li>==常函数==：如果、exist是某个y0$\in$Y,对于每个x$\in$X都有f(x)=y0,即f(x)={y0}</li>
<li>如果Ix=&lt;x,x&gt;,则称函数为==恒等函数==</li>
</ul>
</li>
<li><p>定理：</p>
<ul>
<li>另X和Y为有限集，若|X|=|Y|，则f:X$\rightarrow$Y是单射的，当且仅当它是一个满射。</li>
<li>设f和g分别是A到B和从B到C的函数，则：</li>
<li>如果f，g是满射，则复合函数$g\circ f$也是从A到C的满射</li>
<li>如果f，g是单射，则$g\circ f$也是从A到C单射</li>
<li>如果f，g是双射，则$g\circ f$也是从A到C的双射</li>
<li><img src="https://i.loli.net/2020/06/22/1tEUk2bzKxnFYjp.png" alt=""></li>
<li></li>
</ul>
</li>
</ol>
<h4 id="集合的运算"><a href="#集合的运算" class="headerlink" title="集合的运算"></a>集合的运算</h4><ul>
<li>集合的并：设任意集合A和B，由所有属于集合A或者属于集合B的元素组成的集合S，称为集合A和B的并集记为$A \bigcup B$</li>
<li>集合的交：设任意集合A和B，由集合A和B的所有共同元素组成的集合称为A和B的交集，记为$A \bigcap B$</li>
<li>绝对补（补运算）：设全集是E，对集合A，E-A是集合A的绝对补。记为~A或者$\overline{A}$</li>
<li>集合的补（差集）：设任意集合A和B，所有属于集合A而不属于集合B的一切元素组成的集合S，称为集合B对于A的补集或者相对补，记为A-B</li>
<li>集合的对称差：设任意集合A和B，A和B的对称差集为集合S，其元素属于A或者属于B，但不能既属于A又属于B。记为A$\bigoplus$B</li>
</ul>
<h4 id="集合的运算性质及定律"><a href="#集合的运算性质及定律" class="headerlink" title="集合的运算性质及定律"></a>集合的运算性质及定律</h4><p>$$<br>幂等律：\<br>A \cup A=A\<br>A \cap A=A\<br>交换律：\<br>A \cup B=B \cup A\<br>A \cap B =B \cap A\<br>结合律：\<br>A \cup (B \cup C)=(A \cup B)\cup C\<br>A \cap (B \cap C)=(A \cap B)\cap C\<br>同一律：\<br>A \cup \emptyset =A\<br>A \cap E（全集）=A\<br>零律：\<br>A \cup E=E\<br>A \cap \emptyset =\emptyset \<br>分配律：<br>A \cup (B \cap C)=(A \cup B)\cap (A \cup C)\<br>A \cap (B \cup C)=(A \cap B)\cup (A \cap C)\<br>吸收律：\<br>A \cup (A \cap B)=A\<br>A \cap  (A \cup B)=A\<br>矛盾律，排中律：\<br>\overline{A}\cap A=\emptyset\<br>\overline{A}\cup A=E\<br>双重否定率：\<br>\overline{\overline{A}}=A\<br>德摩根律：\<br>\overline{A \cup B}=\overline{A}\cap \overline{B}\<br>\overline{A \cap B}=\overline{A}\cap \overline{B}<br>$$</p>
<p><img src="https://i.loli.net/2020/06/20/5xw7tW2ui1NgZ3S.png" alt=""></p>
<p><img src="https://i.loli.net/2020/06/20/1RwENuQUrPZinxG.png" alt=""></p>
<h4 id="笛卡尔积的性质"><a href="#笛卡尔积的性质" class="headerlink" title="笛卡尔积的性质"></a>笛卡尔积的性质</h4><ul>
<li><p>A$\times\emptyset =\emptyset $且$\emptyset \times A=\emptyset $</p>
</li>
<li><p>不适合交换律</p>
</li>
<li><p>不适合结合律</p>
</li>
<li><p>对并和交运算满足分配律</p>
<p><img src="https://i.loli.net/2020/06/20/MKNbgPmIR9q1UnE.png" alt=""></p>
</li>
<li><p>设A,B,C,D是非空集合，则有$A \subseteq C \bigwedge B \subseteq D\leftrightarrow A\times B \subseteq C\times D$</p>
</li>
<li><p>若C非空，则$A \subseteq B\leftrightarrow A\times C \subseteq B\times C \leftrightarrow C\times A \subseteq C\times B$</p>
</li>
</ul>
<h4 id="关系的表示"><a href="#关系的表示" class="headerlink" title="关系的表示"></a>关系的表示</h4><ul>
<li><p>集合表示法：枚举法和叙述法</p>
</li>
<li><p>关系图法：</p>
<p>如R是定义在A＝&lt;a1,a2,a3,…,an&gt;上的关系，则对应于关系R有如下规定：</p>
<ul>
<li><p>设a1,a2,…,an为图中节点，用“。”表示。</p>
</li>
<li><p>如&lt;$a_{i},a_{j}$&gt;$\in$R,则从$a_{i}$到$a_{j}$可用一有向边$a_{i}\rightarrow a_{j}$相连。</p>
</li>
<li><p>如&lt;ai,ai&gt;$\in$R,则从ai到ai用一带箭头的小圆环表示。</p>
</li>
</ul>
</li>
<li><p>关系矩阵法：  设A＝&lt;a1,a2,a3,…,an&gt;，B＝&lt;b1,b2,b3,…,bm&gt;，R是从A到B的一个二元关系，则对应于关系R之关系矩阵MR＝（rij)n×m。</p>
<p><img src="https://i.loli.net/2020/06/20/imFw6typDT4saVK.png" alt=""></p>
<ul>
<li><p>布尔矩阵的并运算，记为A$\or$B=C=c(ij)</p>
<p>如果aij=1或bij=1,则cij=1</p>
</li>
<li><p>交运算：记为A$\land$B=C=cij</p>
<p>如果aij=1且bij=1,则cij=1</p>
</li>
<li><p>积运算：A是m<em>p矩阵，B是p\</em>n 矩阵.</p>
</li>
<li><p>cij=1(存在k，aik=1 and bkj=1)</p>
</li>
</ul>
</li>
</ul>
<h4 id="关系的基本运算"><a href="#关系的基本运算" class="headerlink" title="关系的基本运算"></a>关系的基本运算</h4><ul>
<li>设R,S都是集合A到B的两个关系，则：</li>
</ul>
<p>$$<br>R \cup S={&lt;x,y&gt;|(xRy)\vee(xSy) }\<br>R \cap S={&lt;x,y&gt;|(xRy)\land (sSy)}\<br>R -S={&lt;x,y&gt;|(xRy)\land (xSy)}\<br>根据定义，由于A\times B是相对于R的全集，所以\<br>\overline{R}=A\times B-R,且\overline{R}\cup R=A\times B,\overline{R}\cup R=\emptyset<br>$$</p>
<ul>
<li>关系的复合：设R是一个从集合X到集合Y的二元关系，S是从集合Y到集合Z的二元关系，则RS的复合关系R$\circ$S是从X到Z的关系，并且：$R\circ S={&lt;x,y&gt;|(x \in X)\land (z \in Z)\land (\exist y)((y \in Y)\land (xRy)\land (ySz))}$运算称为复合运算。</li>
</ul>
<p><img src="https://i.loli.net/2020/06/21/dygZuq7viBhN4G9.png" alt=""></p>
<ul>
<li>关系的幂：设R是集合A上的二元关系，则可定义$R^{n}$如下：<ul>
<li>$R^{0}=I_{A}={&lt;a,a&gt;|a \in A}$</li>
<li>$R=R$</li>
<li>$R^{n+1}=R^{n}\circ R=R\circ R^{n}$</li>
</ul>
</li>
<li>逆关系：设R是一个从集合X到集合Y的二元关系，则从Y到X的关系$R^{c}={&lt;b,a&gt;|&lt;a,b&gt;\in R}$称为R的逆关系，运算“c”称为逆运算</li>
<li>$(R\circ S)\circ T=R\circ(S\circ T)$</li>
<li>$(R\circ S)^{c}=S^{c}\circ R^{c}$</li>
<li><img src="https://i.loli.net/2020/06/21/rfej3pmRo8aUHXl.png" alt=""></li>
</ul>
<h4 id="关系的性质"><a href="#关系的性质" class="headerlink" title="关系的性质"></a>关系的性质</h4><ol>
<li><p>设R是集合X上的二元关系：</p>
<ul>
<li><p>对任意的x$\in$X,</p>
<ul>
<li><p>都满足&lt;x,x&gt;$\in$R,则R是自反的。</p>
</li>
<li><p>都满足&lt;x,x&gt;$\not\in R$是反自反的。</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre><code>  对任意的x,y$\in$X

+ 满足&lt;x,y&gt;$\in$R,则有&lt;y,x&gt;$\in$R,则R是对称的。

+ 满足$&lt;x,y&gt;\in R\land&lt;y,x&gt;\in R\rightarrow x=y$则R是反对称的。



  对任意的x,y,z$\in$X

+ 满足&lt;x,y&gt;$\in$R$\land$&lt;y,z&gt;$\in$R$\rightarrow$&lt;x,z&gt;$\in$R，则R是传递的</code></pre><ol start="2">
<li><p>用关系图来描述关系的性质</p>
<ul>
<li>在关系图中，每个节点都有环，则此关系是自反的。</li>
<li>在关系图中，每个节点是无环的，则此关系是反自反的。</li>
<li>在关系图中，任何一个节点之间，要么有方向相反的两条边，要么没有任何边，则此关系是对称的</li>
<li>在关系图中，任何一对节点之间，至多有一条边、exist是。则此关系是反对称的</li>
<li>在关系图中，任何三个节点，x，y，z之间，若从x到y有一条边、exist是，从y到z有一条边存在，则从x到z一定有一条边、exist是，则此关系是传递的</li>
</ul>
</li>
<li><p>用关系矩阵来描述关系的性质</p>
<ul>
<li>在关系矩阵中，对角线上全是1，则此关系是自反的</li>
<li>在关系矩阵中，对角线上全是0，则此关系是反自反的。</li>
<li>若R之关系矩阵是对称矩阵，则此关系是对称的</li>
<li>若关系矩阵是反对称矩阵（关于元素1的反对称），则此关系是反对称的</li>
<li>在关系矩阵中，对任意i,j,k$\in${1,2,3,…,n}，满足如$r_{ij}=1\land r_{jk}=1$则$r_{ik}=1$,则此关系是传递的</li>
</ul>
</li>
<li><p>关于关系性质的一些结论</p>
<p><img src="https://i.loli.net/2020/06/21/efuEbz3TVC2Siw5.png" alt=""></p>
</li>
<li><p>关系性质的逻辑表示</p>
<p><img src="https://i.loli.net/2020/06/21/utXNdPnv3RODKAs.png" alt=""></p>
<p><img src="https://i.loli.net/2020/06/21/p7It3oPgjvdqc2y.png" alt=""></p>
</li>
<li><p>关系性质的证明方法</p>
<p><img src="https://i.loli.net/2020/06/21/eAJKXoZO3YM2clj.png" alt=""></p>
<p><img src="https://i.loli.net/2020/06/21/sjLYHuhM7Aad4Fi.png" alt=""></p>
<p><img src="https://i.loli.net/2020/06/21/HmBny7LsbtYuIDk.png" alt=""></p>
</li>
</ol>
<h4 id="闭包的计算方法"><a href="#闭包的计算方法" class="headerlink" title="闭包的计算方法"></a>闭包的计算方法</h4><p><img src="https://i.loli.net/2020/06/21/a4KFihy3pr6U1sW.png" alt=""></p>
<p><img src="https://i.loli.net/2020/06/21/BvJp8wqNQUta4LX.png" alt=""></p>
<p><img src="https://i.loli.net/2020/06/21/A2B7HkqJwZI8mu1.png" alt=""></p>
<h4 id="特殊元素"><a href="#特殊元素" class="headerlink" title="特殊元素"></a>特殊元素</h4><ol>
<li><p><u><strong>设&lt;A,$\leq$&gt;是偏序集，B是A的任何一个子集。</strong></u></p>
<ul>
<li><u><strong>若存在元素b$\in $B,使得对任意x$\in$B,都有x$\leq$b，则称b为B的最大元素。</strong></u></li>
<li><u><strong>若有元素b$\in$B,使得对任意x$\in$B都有b$\leq$x,则称b为B的最小元素</strong></u></li>
<li><u><strong>若存在元素b$\in$B,使得对任何x$\in$B满足$b\leq x\rightarrow x=b$,则称b为B的极大元素</strong></u></li>
<li><u><strong>若存在元素b$\in$B,使得对任何x$\in$B,满足$x\leq b\rightarrow x=b$,则称b为B的极小元素</strong></u></li>
<li><u><strong>若存在元素a$\in$A,使得对任何x$\in$B,都有x$\leq$B,都有$x\leq a$,则称a为B的上界</strong></u></li>
<li><u><strong>若有是元素a$\in$A，使得对任何x$\in$B，都有a$\leq$x,则称a为B的下界</strong></u></li>
<li><u><strong>若元素a’$\in$A是B的上界，元素a$\in$A是B的任何一个上界，若均有a’$\leq$a，则称a’为B的上确届。</strong></u></li>
<li><u><strong>若元素a’$\in$A是B的下界，元素a$\in$A是B的任何一个下界，若均有a$\leq$a’，则称a’为B的下确界。</strong></u></li>
</ul>
</li>
<li><p>特殊元素的一些结论：</p>
<ol>
<li><p>B的最大元、最小元、极大元和极小元如果存在是，一定在B中。</p>
</li>
<li><p>b是B的最大元$\leftrightarrow$B中所有的元素都比b小。</p>
<p>b是B的最小元$\leftrightarrow$B中所有的元素都比b大</p>
<p>b是B的极大元$\leftrightarrow$B中没有比b大的元素</p>
<p>b是B的极小元$\leftrightarrow$B中没有比b小的元素</p>
</li>
<li><p>子集B的上下界和上下确界可在集合A中寻找</p>
</li>
<li><p>子集B的上下界不一定存在，如果存在可能多个</p>
</li>
<li><p>子集B的上下确界不一定存在，如果存在一定唯一</p>
</li>
<li><p>子集B有上下确界就一定有上下界，反之不成立</p>
<p><img src="https://i.loli.net/2020/06/22/8FzgswpElLHPa7W.png" alt=""></p>
</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/03/%E7%8E%89%E8%9F%BE%E5%B2%A9%E5%87%BA%E7%8E%B0%E4%BA%BA%E5%B7%A5%E6%A0%BD%E5%9F%B9%E7%A8%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jian Shengnan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="凉介's personal blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/03/%E7%8E%89%E8%9F%BE%E5%B2%A9%E5%87%BA%E7%8E%B0%E4%BA%BA%E5%B7%A5%E6%A0%BD%E5%9F%B9%E7%A8%BB/" class="post-title-link" itemprop="url">科技史—玉蟾岩出现人工栽培稻</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-07-03 00:00:00 / Modified: 17:04:15" itemprop="dateCreated datePublished" datetime="2020-07-03T00:00:00+08:00">2020-07-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%A8%E5%8E%86%E5%8F%B2/" itemprop="url" rel="index"><span itemprop="name">全历史</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="科技史-玉蟾岩出现人工栽培稻"><a href="#科技史-玉蟾岩出现人工栽培稻" class="headerlink" title="科技史-玉蟾岩出现人工栽培稻"></a>科技史-玉蟾岩出现人工栽培稻</h1><blockquote>
<p>约公元前8000年 亚洲</p>
<p>玉蟾岩遗址栽培稻种的发现，对探讨中国史前稻作农业的起源具有重要的价值。</p>
</blockquote>
<p>玉蟾岩遗址位于中国湖南省道县，是一处洞穴遗址。在那里发现了4粒稻谷，经鉴定兼有野、籼（xian）、粳（jing）稻的综合特征，为演化中的最原始的古栽培稻类型。这是迄今为止中国所发现的最早的古栽培稻实物，也是世界上最早的栽培稻实物标本。</p>
<p>同时，土样分析也表明存在水稻的硅酸体，说明当时已开始少量栽培最原始的水稻。经碳14法断代测定，稻谷遗存年代约公元前8000年。</p>
<p>玉蟾岩遗址栽培稻种的发现，对探讨中国史前稻作农业的起源具有重要的价值。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/03/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%AE%9E%E9%AA%8C%EF%BC%9A%E5%85%B3%E7%B3%BB%E6%80%A7%E8%B4%A8%E5%88%A4%E6%96%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jian Shengnan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="凉介's personal blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/03/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%AE%9E%E9%AA%8C%EF%BC%9A%E5%85%B3%E7%B3%BB%E6%80%A7%E8%B4%A8%E5%88%A4%E6%96%AD/" class="post-title-link" itemprop="url">离散数学实验：关系性质判断</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-07-03 00:00:00 / Modified: 17:44:47" itemprop="dateCreated datePublished" datetime="2020-07-03T00:00:00+08:00">2020-07-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="离散数学实验：关系性质判断"><a href="#离散数学实验：关系性质判断" class="headerlink" title="离散数学实验：关系性质判断"></a>离散数学实验：关系性质判断</h1><h2 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h2><blockquote>
<p><strong>熟悉关系的性质，掌握求判断关系性质的方法。</strong></p>
</blockquote>
<h2 id="二、实验内容"><a href="#二、实验内容" class="headerlink" title="二、实验内容"></a>二、实验内容</h2><blockquote>
<p><strong>本实验要求从键盘输入一个关系的关系矩阵，判断该关系是否是自反的、对称的、传递的、反自反的、反对称的。用C语言或MATLAB实现。</strong></p>
</blockquote>
<h2 id="三、实验源程序"><a href="#三、实验源程序" class="headerlink" title="三、实验源程序"></a>三、实验源程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS<span class="comment">//避免scanf编译不通过</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Input</span><span class="params">()</span></span>;<span class="comment">//输入关系矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Ref</span><span class="params">()</span></span>;<span class="comment">//判断是否自反</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">NoRef</span><span class="params">()</span></span>;<span class="comment">//判断是否反自反</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Sym</span><span class="params">()</span></span>;<span class="comment">//判断是否对称</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">NoSym</span><span class="params">()</span></span>;<span class="comment">//判断是否反对称</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Tra</span><span class="params">()</span></span>;<span class="comment">//判断是否传递</span></span><br><span class="line"><span class="keyword">int</span> matrix[<span class="number">100</span>][<span class="number">100</span>]&#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">line</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Input();</span><br><span class="line">	<span class="keyword">if</span> (Ref())</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"该关系是自反的\n"</span>);</span><br><span class="line">	<span class="keyword">if</span> (NoRef())</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"该关系是反自反的\n"</span>);</span><br><span class="line">	<span class="keyword">if</span> (Sym())</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"该关系是对称的\n"</span>);</span><br><span class="line">	<span class="keyword">if</span> (NoSym())</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"该关系是反对称的\n"</span>);</span><br><span class="line">	<span class="keyword">if</span> (Tra())</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"该关系是传递的！\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Input</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"请输入关系矩阵的行列数(行列数小于等于100)：\n"</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;<span class="built_in">line</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">line</span> &gt; <span class="number">100</span> || <span class="built_in">line</span> &lt; <span class="number">1</span>)<span class="comment">//判断行列数是否合法</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"非法输入！\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"请输入关系矩阵：\n"</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="built_in">line</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="built_in">line</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;matrix[i][j]);</span><br><span class="line">			<span class="keyword">if</span> (matrix[i][j] &gt;= <span class="number">2</span> || matrix[i][j] &lt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"输入关系矩阵错误\n"</span>);</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Tra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="built_in">line</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="built_in">line</span>;j++)<span class="comment">//二重数组遍历关系矩阵</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (matrix[i][j] == <span class="number">1</span>)<span class="comment">//如果第i行j列的元素是1</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; <span class="built_in">line</span>;k++)<span class="comment">//开始搜索第j行为1的元素</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (matrix[j][k] == <span class="number">1</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">if</span> (matrix[i][k] != <span class="number">1</span>)</span><br><span class="line">							<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果存在这种情况：第i行第j</span></span><br><span class="line"><span class="comment">//列和第j行第k列的元素均为1，但是第i行第k列的元素不为1，则不具有传递性</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Ref</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="built_in">line</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (matrix[i][i] != <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//只要主对角线元素存在非1元素，即不具有自反性</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">NoRef</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="built_in">line</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (matrix[i][i] != <span class="number">0</span>)<span class="comment">//只要对角线存在非0元素，即不具有反自反性</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Sym</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="built_in">line</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="built_in">line</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (matrix[i][j] != matrix[j][i])</span><br><span class="line">	<span class="comment">//只要第i行第j列元素和第j行第i列元素不相等，即不是对称矩阵，则不具有对称性</span></span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">NoSym</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="built_in">line</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="built_in">line</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (matrix[i][j] == matrix[j][i] </span><br><span class="line">			        &amp;&amp; (matrix[i][j] == <span class="number">1</span> || matrix[j][i] == <span class="number">1</span>))</span><br><span class="line">	<span class="comment">//只要存在两个对称位置元素中，存在一个为1，另一个同样为1，则不具有反对称性</span></span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、实验分析"><a href="#四、实验分析" class="headerlink" title="四、实验分析"></a>四、实验分析</h2><p><strong>实验要求利用关系矩阵判断五个性质，我们要了解这些性质在关系矩阵的体现是什么。正如源代码中的注释。之后，码代码是很简单的。</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/03/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%AE%9E%E9%AA%8C%EF%BC%9A%E5%85%B3%E7%B3%BB%E9%97%AD%E5%8C%85%E7%9A%84%E8%AE%A1%E7%AE%97(C%E8%AF%AD%E8%A8%80)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jian Shengnan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="凉介's personal blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/03/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%AE%9E%E9%AA%8C%EF%BC%9A%E5%85%B3%E7%B3%BB%E9%97%AD%E5%8C%85%E7%9A%84%E8%AE%A1%E7%AE%97(C%E8%AF%AD%E8%A8%80)/" class="post-title-link" itemprop="url">离散数学实验：关系闭包的计算</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-07-03 00:00:00 / Modified: 17:45:17" itemprop="dateCreated datePublished" datetime="2020-07-03T00:00:00+08:00">2020-07-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="离散数学实验：关系闭包的计算-C语言"><a href="#离散数学实验：关系闭包的计算-C语言" class="headerlink" title="离散数学实验：关系闭包的计算(C语言)"></a>离散数学实验：关系闭包的计算(C语言)</h1><h2 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h2><blockquote>
<p><strong>熟悉Warshall算法，掌握求关系的自反闭包、对称闭包和传递闭包的方法。</strong></p>
</blockquote>
<h2 id="二、实验内容"><a href="#二、实验内容" class="headerlink" title="二、实验内容"></a>二、实验内容</h2><blockquote>
<p><strong>Warshall算法：设R是n个元素集合上的二元关系，M是R的关系矩阵；<br>(1)    置新矩阵A:=M<br>(2)    置i:=1；<br>(3)    for j=1 to n do<br>        if  A[j,i]=1 then do<br>       for  k=1  to  n  do<br>               A[j,k]:=A[j,k]+A[i,k]<br>(4)    i=i+1；<br>(5)     if  i&lt;=n  then  to  (3)<br>       else stop<br>本实验要求从键盘输入一个关系的关系矩阵，计算其自反闭包、对称闭包和传递闭包，计算传递闭包时使用Warshall算法。用C语言或MATLAB实现。</strong></p>
</blockquote>
<h2 id="三-实验源程序"><a href="#三-实验源程序" class="headerlink" title="三.实验源程序"></a>三.实验源程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> matrix[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RClosure</span><span class="params">()</span></span>;<span class="comment">//计算自反闭包</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SClosure</span><span class="params">()</span></span>;<span class="comment">//计算对称闭包</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TClosure</span><span class="params">()</span></span>;<span class="comment">//计算传递闭包</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Input</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Display</span><span class="params">(<span class="keyword">int</span> a[<span class="number">100</span>][<span class="number">100</span>])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Input();</span><br><span class="line">	RClosure();</span><br><span class="line">	SClosure();</span><br><span class="line">	TClosure();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Display</span><span class="params">(<span class="keyword">int</span> a[<span class="number">100</span>][<span class="number">100</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Input</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"请输入该关系矩阵的阶数(小于等于100)：\n"</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">0</span> || n&gt;<span class="number">100</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"非法输入！\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"请输入关系矩阵：\n"</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;matrix[i][j]);</span><br><span class="line">			<span class="keyword">if</span> (matrix[i][j] &gt; <span class="number">1</span> || matrix[i][j] &lt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"非法输入！\n"</span>);</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RClosure</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			a[i][j] = matrix[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		a[i][i] = <span class="number">1</span>;<span class="comment">//让所有主对角线的元素全是1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"自反闭包是：\n"</span>);</span><br><span class="line">	Display(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SClosure</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			a[i][j] = matrix[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (a[i][j] == <span class="number">1</span>)</span><br><span class="line">			<span class="comment">//如果第i行第j列元素是1，那让第j行第i列的元素也为1</span></span><br><span class="line">				a[j][i] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"对称闭包是：\n"</span>);</span><br><span class="line">	Display(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TClosure</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			a[i][j] = matrix[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> i, j, k;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (a[j][i] &gt;= <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span> (k = <span class="number">0</span>;k &lt; n;k++)</span><br><span class="line">				&#123;</span><br><span class="line">					a[j][k] = a[j][k] + a[i][k];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (a[i][j] &gt; <span class="number">1</span>)</span><br><span class="line">				a[i][j] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"传递闭包是：\n"</span>);</span><br><span class="line">	Display(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、实验分析"><a href="#四、实验分析" class="headerlink" title="四、实验分析"></a>四、实验分析</h2><p><strong>只要把Warshall算法伪代码转换成代码，其余的easy.</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/03/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jian Shengnan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="凉介's personal blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/03/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91/" class="post-title-link" itemprop="url">数理逻辑知识总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-07-03 00:00:00 / Modified: 17:20:23" itemprop="dateCreated datePublished" datetime="2020-07-03T00:00:00+08:00">2020-07-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="离散数学"><a href="#离散数学" class="headerlink" title="离散数学"></a>离散数学</h1><h2 id="数理逻辑"><a href="#数理逻辑" class="headerlink" title="数理逻辑"></a>数理逻辑</h2><h3 id="命题逻辑"><a href="#命题逻辑" class="headerlink" title="命题逻辑"></a>命题逻辑</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ol>
<li><p>==命题==：具有确切真值的陈述句称为命题。</p>
</li>
<li><p>==真值==：一个命题总有一个值，一般来讲，命题是正确的则真值为真，命题为错误的真值为假，这称为命题的真值。     真值只有真假两种，分别用“T”（1）和“F”（0）表示。</p>
</li>
<li><p>==原子（简单）命题==：不能再分解为更简单命题的命题。</p>
</li>
<li><p>==复合命题==：可以分解的命题</p>
</li>
<li><p>==命题变量==：一个表示确定命题的命题标识符</p>
</li>
<li><p>==命题变元==：表示任一命题的命题标识符。（命题变元不是命题）</p>
</li>
<li><p>==原子变元==：命题变元是原子命题</p>
</li>
<li><p>==指派/解释==：当命题变元P用一个特定的命题取代时，P才能确定真值，称为对P进行指派。若公式G在解释I下是真，则称I满足G，I是G的成真赋值。反之称I弄假于G。</p>
</li>
<li><p>==命题公式==：由命题变量、命题变元、联结词和括号等组成的复合命题形式，这些符号不能任意组合，必须按下列定义：</p>
<ol>
<li>命题变元本身是一个公式</li>
<li>若P是公式，<strong>┐</strong>P也是公式</li>
<li>如PQ是公式，则P$\land$Q、P$\lor$Q,P$\rightarrow$Q,P$\leftrightarrow$Q也是公式</li>
<li>仅由有限步骤使用规则1-3后产生的结果。</li>
</ol>
</li>
<li><p>==真值表==：公式G在其所有可能的解释下所取真值的表。</p>
</li>
<li><p>==等价公式==：给定两个命题公式A和B，P1，P2，…Pn为所有于出现、并A和B中的原子变元，若给所有命题变元任一组真值指派，A和B的真值相同，则称A和B是等价的或者逻辑相等。充分必要条件是，G$\leftrightarrow$H</p>
</li>
<li><p>[基本等价公式](#### 基本等价公式)</p>
</li>
<li><p>==子公式==：如果X是合式公式A的一部分，且X本身也是一个合式公式，则称X为公式A的子公式。</p>
</li>
<li><p>==等价置换==：设X是合式公式A的子公式，若X$\leftrightarrow$Y,如果将A中的X用Y来置换，所得公式B和公式A等价。</p>
</li>
<li><p>==合取范式==：一个命题公式称为合取范式，当且仅当它具有形式：$A_{1}\land A_{2}\land \cdots \land A_{n}(n\geq 1)$其中A都是由命题变元或其否定所组成的析取式。</p>
</li>
<li><p>==析取范式==：$A_{1}\lor A_{2}\lor \cdots A_{n}(n\geq 1)$其中A都是由命题变元、逼格额其否定所组成的合取式。</p>
</li>
<li><p>命题公式的析取范式可以指出公式何时为真，而合取范式可以指出公式何时为假，从而代替真值表。</p>
</li>
<li><p>==小项==：n个命题变元的合取式，称为布尔合取或小项，但是每个变元、并为和他的否定不能同时、exist是，但两者必须出现且仅出现一次。</p>
<ol>
<li>每个小项当其真值指派、并为大哥编码相同时，其真值为T，其余情况都是F</li>
<li>两个不同小项的合取永假</li>
<li>全体小项的析取式永真</li>
</ol>
</li>
<li><p>==主析取范式==：对于给定的命题公式，如果有一个等价公式，它仅由小项的析取所组成，则该等价公式称作原式的主析取范式。在真值表中，是真值为1的指派所对应小项的析取。</p>
</li>
<li><p>==大项==：n个命题变元的析取式，称作布尔析取、逼格额大项，其中每个变元和她的否定不能同时存在，但两者必须出现且仅出现一次。</p>
<ol>
<li>每个大项当其真值指派、并为大哥编码相同时，其真值是F，其余均为T</li>
<li>任何两个不同大项的析取式永真</li>
<li>全体大项的合取式永假</li>
</ol>
</li>
<li><p>==主合取范式==：对于给定的命题公式，如果有一个等价公式，它仅由大项的合取组成，则该等价式称为原式的主合取范式。在真值表中，一个公式的真值为F的指派所对应的大项的合取，即为此公式的主合取范式。</p>
</li>
<li><p>命题公式永真但且仅当它的主析取范式包含所有的小项，主合取范式为空。永假公式反之。</p>
</li>
<li><p>两个命题公式相等当且仅当它们的主析取范式、主合取范式相等。</p>
</li>
<li><p>==永真公式（重言式）==：所有解释之下都是真</p>
</li>
<li><p>==永假公式（矛盾式）==：在所有的解释之下都是假</p>
</li>
<li><p>==可满足==的，不是永假</p>
</li>
<li><p>==蕴含==：当且仅当P→Q是一个重言式时，称P蕴含Q，记作P$\rightarrow$Q。</p>
</li>
<li><p>==推理==：设A和C是两个命题公式，当且仅当A$\rightarrow$C为永真公式，成C是A的有效结论。C由A逻辑地推出。定义可以推广到n个前提的情况，C为一组前提的有效结论。</p>
</li>
<li><p>其他联结词：</p>
<p><img src="https://i.loli.net/2020/06/19/mixId3CSAGO6nhz.png" alt=""></p>
<p><img src="https://i.loli.net/2020/06/19/wrfLA1uDRqElPbn.png" alt=""></p>
</li>
<li><p>==最小联结词组==：设有一联结词集合A，A中的联结词的等价公式可表达任何命题公式，删除A中的任何一个联结词，至少有一个命题公式B不能表达。</p>
<p><img src="https://i.loli.net/2020/06/19/6lb5drYQsO3ogCi.png" alt="">                                             </p>
</li>
</ol>
<h4 id="联结词"><a href="#联结词" class="headerlink" title="联结词"></a>联结词</h4><table>
<thead>
<tr>
<th align="center">联结词</th>
<th align="center">记号</th>
<th align="center">记法</th>
<th align="center">真值结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">否定</td>
<td align="center"><strong>┐</strong></td>
<td align="center"><strong>┐</strong>P</td>
<td align="center"><strong>┐</strong>P为真当且仅当P为假</td>
</tr>
<tr>
<td align="center">合取</td>
<td align="center">$\land $</td>
<td align="center">P$\land $Q</td>
<td align="center">P$\land $Q为真当且仅当PQ同时为真</td>
</tr>
<tr>
<td align="center">析取</td>
<td align="center">$\lor $</td>
<td align="center">P$\lor $Q</td>
<td align="center">当且仅当PQ中至少一个是真</td>
</tr>
<tr>
<td align="center">条件</td>
<td align="center">$\rightarrow$</td>
<td align="center">P$\rightarrow$Q</td>
<td align="center">为假当且仅当P为真Q为假</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">$\leftrightarrow$</td>
<td align="center">P$\leftrightarrow$Q</td>
<td align="center">当且仅当PQ同真假</td>
</tr>
</tbody></table>
<p><img src="https://i.loli.net/2020/06/19/mqZ31RbczL6Gs5K.png" alt=""></p>
<p>联结词的优先级：非，合取，析取，条件，双条件                                                                                         </p>
<h4 id="命题符号化"><a href="#命题符号化" class="headerlink" title="命题符号化"></a>命题符号化</h4><ol>
<li>确定给定句子是否为命题</li>
<li>列出原子命题</li>
<li>句子中连词是否为命题联结词</li>
<li>根据命题含义，正确表示原子和适当选择命题联结词</li>
</ol>
<h4 id="基本等价公式"><a href="#基本等价公式" class="headerlink" title="基本等价公式"></a>基本等价公式</h4><p>$$<br>幂等律：G \land G=G\<br>G \lor G=G\<br>交换律：G\land H=H\lor G\<br>G\lor H=H\lor G\<br>结合律：G\lor(H\lor S)=(G\lor H)\lor S\<br>G\and (H\land S)=(G\land H)\land S\<br>同一律：G\lor 0=G\<br>G\land 1=G\<br>零律：G\lor 1=1\<br>G\land 0=0\<br>分配律：G\lor (H\land S)=(G\lor H)\land(G\lor S)\<br>G\land(H\lor S)=(G\land H)\lor(G\land S)\<br>吸收律：G\lor (G\land H)=G\<br>G\land(G\lor H)=G\<br>矛盾律：┐G\land G=0\<br>排中律：┐G\lor G=1\<br>双重否定律：┐(┐G)=G\<br>德摩根律：┐(G\lor H)=┐G\land ┐H\<br>┐(G\land H)=┐G\lor ┐H\<br>蕴含式：G\rightarrow H=┐G\lor H\<br>假言易位：G\rightarrow H=┐H\rightarrow ┐G\<br>等价式：G\leftrightarrow H=(G\rightarrow H)\land(H\rightarrow G)=(┐G\lor H)\land(┐H\lor G)\<br>归谬论：(G\rightarrow H)\land(G\rightarrow ┐H)=┐G<br>$$</p>
<h4 id="判断命题公式逻辑等价的方法"><a href="#判断命题公式逻辑等价的方法" class="headerlink" title="判断命题公式逻辑等价的方法"></a>判断命题公式逻辑等价的方法</h4><ol>
<li>真值表</li>
<li>基本等价公式</li>
<li>等值置换</li>
<li>等值关系的传递性</li>
</ol>
<h4 id="求合取范式和析取范式的方法"><a href="#求合取范式和析取范式的方法" class="headerlink" title="求合取范式和析取范式的方法"></a>求合取范式和析取范式的方法</h4><ol>
<li>简化联结词：将公式中的联结词化归成合取，析取以及非。</li>
<li>否定深入：利用德摩根律将“非”直接移到各个命题变元之前。</li>
<li>归约：利用分配律、结合律归约成合取范式、逼格额析取范式</li>
</ol>
<h4 id="求出主析取范式的方法"><a href="#求出主析取范式的方法" class="headerlink" title="求出主析取范式的方法"></a>求出主析取范式的方法</h4><ol>
<li><p>公式的真值表</p>
</li>
<li><p>基本等价公式</p>
<ol>
<li>化归为析取范式</li>
<li>除去析取范式中所有永假的析取项</li>
<li>将析取式中重复出现的析取项和相同的变元合并</li>
<li>对析取项补入没有出现的命题变元，添加（P析取非P），然后，用分配律展开</li>
</ol>
<p><img src="https://i.loli.net/2020/06/19/6FROMrvcQk25Yqn.png" alt=""></p>
</li>
</ol>
<h4 id="求主合取范式的方法"><a href="#求主合取范式的方法" class="headerlink" title="求主合取范式的方法"></a>求主合取范式的方法</h4><ol>
<li>真值表</li>
<li>基本等价公式<ol>
<li>划归为合取范式</li>
<li>除去合取范式中永真的合取项</li>
<li>合并相同的合取项和相同的变元</li>
<li>对合取项补入没有出现的命题变元，即添加（P合取非P）式，然后，分配律展开</li>
</ol>
</li>
</ol>
<h4 id="主范式间的转换"><a href="#主范式间的转换" class="headerlink" title="主范式间的转换"></a>主范式间的转换</h4><p><img src="https://i.loli.net/2020/06/19/jTeqGPKgpC5ILkD.png" alt=""></p>
<p><img src="https://i.loli.net/2020/06/19/fdyGlS79JLbIq8E.png" alt=""></p>
<h4 id="证明永真（假）的方法"><a href="#证明永真（假）的方法" class="headerlink" title="证明永真（假）的方法"></a>证明永真（假）的方法</h4><ol>
<li>真值表</li>
<li>证明和T（F）等价</li>
</ol>
<h4 id="证明蕴含的方法"><a href="#证明蕴含的方法" class="headerlink" title="证明蕴含的方法"></a>证明蕴含的方法</h4><ol>
<li>指定前件真值为T，若由此推出Q的真值也是T，得证</li>
<li>指定后件Q的真值是F，若由此推出P的真值也是F，得证</li>
</ol>
<h4 id="常用的蕴含式"><a href="#常用的蕴含式" class="headerlink" title="常用的蕴含式"></a>常用的蕴含式</h4><p><img src="https://i.loli.net/2020/06/19/Wrljb1IqGkwLf5Q.png" alt=""></p>
<p><img src="https://i.loli.net/2020/06/19/IWtqrju9eXMhCDP.png" alt=""></p>
<h4 id="推理的方法"><a href="#推理的方法" class="headerlink" title="推理的方法"></a>推理的方法</h4><ol>
<li><p>真值表法</p>
<ol>
<li>在所有行中，只要有一行的前提是真，结论是真，则得证</li>
<li>在所有行中，只要有一行的结论是假，且前提也是假，则得证</li>
</ol>
</li>
<li><p>直接证法</p>
<p>推理规则：</p>
<ol>
<li>规则P（前提引入规则）：前提在推到过程中随时引入。</li>
<li>规则T（逻辑结果引入规则）：在推导过程中，如果有一个、多个公式蕴含着公式S，则公式S可以引入推导之中。</li>
<li>规则CP（附加前提规则）：如果能从给定的前提集合T和公式P推导出S，则能从此T推导出P$\rightarrow$S(使用场景是结论公式是蕴含式或者析取式)</li>
</ol>
<p><img src="https://i.loli.net/2020/06/19/HBjic4ZdtR65DKo.png" alt=""></p>
</li>
<li><p>间接证法</p>
<p><img src="https://i.loli.net/2020/06/19/rANkJ5qsECfKucp.png" alt=""></p>
<p><img src="https://i.loli.net/2020/06/19/U4ywEjnlBuSF8tx.png" alt=""></p>
</li>
</ol>
<h3 id="谓词逻辑"><a href="#谓词逻辑" class="headerlink" title="谓词逻辑"></a>谓词逻辑</h3><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><ol>
<li>在句子中可以独立存在的客体称为==个体词==，而用以刻画客体的属性或者客体之间关系的是==谓词==。</li>
<li>表示具体或者特定的个体词称为==个体常量==</li>
<li>表示抽象或者泛指的个体词称为==个体变量==</li>
<li>个体词的取值范围叫做==个体域==或论域，常用D表示。而宇宙间所有个体域聚集在一起所构成的个体域称为==全总个体域==</li>
<li>==简单命题函数==：由一个谓词、一些客体变元组成的表达式</li>
<li>==复合命题函数==：由一个或者n个简单命题函数以及逻辑连接词组合而成的表达式</li>
<li>==命题函数==：简单命题函数和复合命题函数的统称</li>
<li>命题函数不是命题，只有客体变元取特定的名称时才能成为一个命题。</li>
<li>全称量词：$\forall$,存在量词：$\exist$</li>
<li>($\forall$x)F(x)或($\exist$x)F(x)中，x称为==作用变量==，F(x)称为量词的==辖域==。 </li>
<li>特性谓词加入命题函数中是遵循的原则：<ol>
<li>对于全程量词，刻画其对应个体域的特性谓词作为蕴含的前件加入</li>
<li>对于存在量词，刻画其对应个体域的特性谓词作为合取式之合取项加入</li>
</ol>
</li>
<li>==谓词公式==：<ul>
<li>原子谓词公式是谓词公式</li>
<li>若A是谓词公式，非A也是谓词公式</li>
<li>若AB是谓词公式，则他们的合取，析取，条件，双条件都是谓词公式</li>
<li>若A是谓词公式，X是A中出现的变元，则（$\forall$x）A与($\exist$x)A也是谓词公式</li>
<li>有限次上述过程得到的</li>
</ul>
</li>
<li>==函数符号==：表示个体词之间的转换，如F(x):x的父亲</li>
<li>==项==：任意的常量符号或者任意的变量符号是项。若f(x1,x2,…xn)是n元函数符号，t1,t2…tn是项，则f（t1,…tn）是项</li>
<li>==原子公式==：若P(x1,…xn)是n元谓词，t1…tn是项，则称P(t1…tn)为原子公式</li>
<li>==合式公式==：<ul>
<li>原子公式</li>
<li>原子公式的非，析取，合取，条件，双条件</li>
<li>原子公式前加量词</li>
<li>以上三种的有限次组合</li>
</ul>
</li>
<li>==作用变元==：量词后所跟的x叫做量词的指导变元或作用变元</li>
<li>==作用域==：P（x）叫做相应量词的作用域或辖域</li>
<li>==约束变元==：在作用域中变元x的出现称为约束出现，此时的变元x称为约束变元</li>
<li>==自由变元==：若x的出现不是约束出现，则称它为自由出现，此时的变元称为自由变元。</li>
<li>==闭式==：无自由变元的公式</li>
<li>==约束变元的改名==：（约束变元的改名规则）<ul>
<li>将量词中出现的变元以及该量词辖域中此变量之所有约束出现都用新的变元替换</li>
<li>新的变元一定要有别与改名辖域中所有其它变量</li>
</ul>
</li>
<li>==自由变元的代入==（自由变元的代入规则）<ul>
<li>将公式中出现该自由变元的每一处都用新的变元替换</li>
<li>新变元不允许在原公式中以任何约束形式出现</li>
</ul>
</li>
<li>==赋值/解释==：在谓词公式中客体变元由确定的客体取代，命题变元由确定的命题取代。</li>
<li>==等价式==：给定的两个谓词公式，设他们有共同的个体域E，若对A与B的任一组变元进行赋值，所得命题的真值相同，则称谓词公式A和B在E上是等价的。</li>
<li>==前束范式==：一个公式，如果量词全在公式开头，它们的作用域延伸到公式末尾，则该公式叫做前束范式。</li>
</ol>
<h4 id="谓词中的基本等价公式"><a href="#谓词中的基本等价公式" class="headerlink" title="谓词中的基本等价公式"></a>谓词中的基本等价公式</h4><p>$$<br>改名等价规则：\<br>(\exist x)G(x)=(\exist y)=G(y)\<br>(\forall x)G(x)=(\forall y)G(y)\<br>(\forall x)G(x)\lor (\forall x)H(x)=(\forall x)(\forall y)(G(x)\lor H(y))\<br>(\exist x)G(x)\land (\exist x)H(x)=(\exist x)(\exist y)(G(x)\land H(y))\<br>量词转换律：\<br>┐(\exist x)G(x)=(\forall x)┐G(x)\<br>┐(\forall x)G(x)=(\exist x)┐G(x)\<br>量词分配律：\<br>(\forall x)(A(x)\land B(x))=(\forall x)A(x)\land (\forall x)B(x)\<br>(\exists x)(A(x)\lor B(x))=(\exists x)A(x)\lor (\exists x)B(x)\<br>量词作用域的扩张和收缩：\<br>(\forall x)(A(x)\lor B)=(\forall x)A(x)\lor B\<br>(\forall x)(A(x)\land B)=(\forall x)A(x)\land B\<br>(\exists x)(A(x)\lor B)=(\exists x)A(x)\lor B\<br>(\exists x)(A(x)\land B)=(\exists x)A(x)\land B\<br>(\forall x)(\forall y)A(x,y)=(\forall y)(\forall x)A(x,y)\<br>(\exist x)(\exist y)A(x,y)=(\exist y)(\exist x)A(x,y)<br>$$</p>
<p><img src="https://i.loli.net/2020/06/20/ocm2BgxVZUStiPh.png" alt=""></p>
<p><img src="https://i.loli.net/2020/06/20/6ZDHmNkMB2RrWqz.png" alt=""></p>
<h4 id="常用的蕴含关系"><a href="#常用的蕴含关系" class="headerlink" title="常用的蕴含关系"></a>常用的蕴含关系</h4><p><img src="https://i.loli.net/2020/06/20/9jyO8vkitmKaSQ4.png" alt=""></p>
<h4 id="化为前束范式的方法"><a href="#化为前束范式的方法" class="headerlink" title="化为前束范式的方法"></a>化为前束范式的方法</h4><ol>
<li>消去条件，双条件联结词</li>
<li>┐内移</li>
<li>变元换名</li>
<li>量词提前</li>
</ol>
<p>例题：</p>
<p><img src="https://i.loli.net/2020/06/20/cpAKX4PSzCukwg8.png" alt=""></p>
<h4 id="推理规则"><a href="#推理规则" class="headerlink" title="推理规则"></a>推理规则</h4><p>全称特指规则（US）：$(\forall x)P(x)\rightarrow P(c)$</p>
<ul>
<li>x是P（x）中自由出现的个体变量</li>
<li>c是任意的个体变量</li>
</ul>
<p>存在特指规则（ES）：$(\exist x)P(x)\rightarrow P(c)$</p>
<ul>
<li>x是P（x）中自由出现的个体变量</li>
<li>在P（x）中变元x的每一次自由出现都用相同的个体变量c代入</li>
<li>c是使P(x)为真的特定个体变量</li>
<li>此c是在推导之前从未使用过的</li>
</ul>
<p>全称推广规则（UG）：$P(y)\rightarrow (\forall x)P(x)$</p>
<ul>
<li>y是P(y)中自由出现的个体变量。且y取遍整个个体域时都有P（y）为真</li>
<li>对P(y)中不满足假设前提（使P(y)为真）的自由变元y不能使用该规则</li>
<li>添加的量词中的x和取代y的x不能在P(y)中以约束身份出现</li>
<li>对于曾经由使用规则ES所得公式中原来的约束变元不能使用该规则</li>
</ul>
<p>存在推广规则（EG）：$P(c)\rightarrow(\exist x)P(x)$</p>
<ul>
<li>c是使P(c)为真的特定个体变量</li>
<li>取代c的x和添加的量词中的x不能在P(c)中以任何约束出现</li>
</ul>
<h4 id="谓词推理中注意的问题"><a href="#谓词推理中注意的问题" class="headerlink" title="谓词推理中注意的问题"></a>谓词推理中注意的问题</h4><ul>
<li><p>在推导中，可引用命题演算中的P、T和CP规则。</p>
</li>
<li><p>为了在推导中消去量词，可引用US和ES来消去量词。</p>
</li>
<li><p>当结论可能被定量时，可引用UG和EG将其量词加入。</p>
</li>
<li><p>证明时可采用如命题演算中的直接证法和间接证法。</p>
</li>
<li><p>在推导中，对消去量词的公式或公式中没含量词的子公式，完全可引用命题演算中的基本等价和蕴涵公式。</p>
</li>
<li><p>在推导中，对含有量词的公式可引用谓词中的基本等价和蕴涵公式。</p>
</li>
<li><p>在推导中，如既要使用US又要使用ES消去公式中的词,只要有可能，总是先使用ES，再使用US。然后再用命题演算中的推理规则，最后使用UG或EG引入量词，得到所要的结论。</p>
</li>
<li><p>如一个变量是用ES消去量词，对该变量在添加量词时，则只能使用EG，而不能使用UG;如使用US消去量词，对该变量在添加量词时，则可使用EG和UG。</p>
</li>
<li><p>如有两个含有存在量词的公式，当用ES消去量词时，不能选用同样的一个常量符号来取代两个公式中的变元，而应用不同的常量符号来取代它们。</p>
</li>
<li><p>在用US和ES消去量词时，此量词必须位于整个公式的最前端。</p>
</li>
<li><p>在添加的量词($\forall $x)、($\exists$x)时，所选用的x不能在公式P(c)中以任何约束出现。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/03/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%AE%9E%E9%AA%8C%EF%BC%9A%E8%AE%A1%E7%AE%97%E7%9C%9F%E5%80%BC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jian Shengnan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="凉介's personal blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/03/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%AE%9E%E9%AA%8C%EF%BC%9A%E8%AE%A1%E7%AE%97%E7%9C%9F%E5%80%BC/" class="post-title-link" itemprop="url">离散数学实验：计算真值</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-07-03 00:00:00 / Modified: 17:44:52" itemprop="dateCreated datePublished" datetime="2020-07-03T00:00:00+08:00">2020-07-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="离散数学实验：计算真值"><a href="#离散数学实验：计算真值" class="headerlink" title="离散数学实验：计算真值"></a>离散数学实验：计算真值</h1><h2 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h2><blockquote>
<p><strong>熟悉五个常用联结词合取、析取、条件和双条件的概念，掌握真值表技术。</strong></p>
</blockquote>
<h2 id="二、实验内容"><a href="#二、实验内容" class="headerlink" title="二、实验内容"></a>二、实验内容</h2><blockquote>
<p><strong>本实验要求从键盘输入两个命题P和Q的真值，求它们的合取、析取、条件和双条件的真值。用C语言或MATLAB实现。</strong></p>
</blockquote>
<h2 id="三、实验源程序"><a href="#三、实验源程序" class="headerlink" title="三、实验源程序"></a>三、实验源程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> P, Q;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"从键盘输入两个命题P和Q的真值\n"</span>);</span><br><span class="line">	scanf_s(<span class="string">"%d %d"</span>, &amp;P, &amp;Q);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"P合取Q为%d\n"</span>, (P &amp;&amp; Q));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"P析取Q为%d\n"</span>, (P || Q));</span><br><span class="line">	<span class="keyword">int</span> judge1, judge2, judge3;</span><br><span class="line">	<span class="keyword">if</span> (P == <span class="number">1</span> &amp;&amp; Q == <span class="number">0</span>)</span><br><span class="line">		judge1 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		judge1 = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"P-&gt;Q为%d\n"</span>, judge1);</span><br><span class="line">	<span class="keyword">if</span> (Q == <span class="number">1</span> &amp;&amp; P == <span class="number">0</span>)</span><br><span class="line">		judge2 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		judge2 = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Q-&gt;P为%d\n"</span>, judge2);</span><br><span class="line">	<span class="keyword">if</span> (Q == P)</span><br><span class="line">		judge3 = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		judge3 = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"P&lt;-&gt;Q为%d"</span>, judge3);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、实验分析"><a href="#四、实验分析" class="headerlink" title="四、实验分析"></a>四、实验分析</h2><p><strong>这是一个简单的实验，明白四个关系的具体含义，利用程序中的对应代码进行替换判断即可。</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/03/%E9%99%B6%E7%AD%B9%E7%9A%84%E5%87%BA%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jian Shengnan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="凉介's personal blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/03/%E9%99%B6%E7%AD%B9%E7%9A%84%E5%87%BA%E7%8E%B0/" class="post-title-link" itemprop="url">科技史—陶筹的出现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-07-03 00:00:00 / Modified: 17:06:18" itemprop="dateCreated datePublished" datetime="2020-07-03T00:00:00+08:00">2020-07-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%A8%E5%8E%86%E5%8F%B2/" itemprop="url" rel="index"><span itemprop="name">全历史</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="科技史-陶筹的出现"><a href="#科技史-陶筹的出现" class="headerlink" title="科技史-陶筹的出现"></a>科技史-陶筹的出现</h1><blockquote>
<p>约公元前8000年 亚洲</p>
<p>陶筹是史前人类长期使用的计数系统，或被视为文字的古老起源。</p>
</blockquote>
<p>一种新兴的理论认为，文字是由一种被长期使用的计数系统陶筹演变而来的，这种陶筹在中东的很多考古遗址中都有发现。当人们开始使用二维的符号来取代陶筹，这就是文字的起源。</p>
<p>公元前8000年左右，早期农业出现的同时，西亚地区出现了一种计数系统，或称“陶筹”。人们用陶筹计数记事，这时的陶筹无孔无洞无刻道，比较原始，因此被称为“朴素陶筹”。这些陶筹非常小其几何形状的实物用泥土制成，代表了不同的货物单位，被用来计数和记录货物，如牲畜、谷物、酒制品，甚至是手工制品等。</p>
<p>4000多年后，大约在公元前3500年，陶筹系统发展到了第二阶段，新的类型和亚型层出不穷，开始出现或打洞、或刻道、或打洞刻道俱全的陶筹。人们使用的陶筹数量和种类越来越多，人们开始把陶筹包裹在空心黏土球里封存。在封存之前，把陶筹的形状压印在封球表面，陶筹的数量则通过相应数量的标记来表示。</p>
<p>人们很快意识到，在封球表面压印了标记之后，封球内的陶筹实际上已毫无用途。因此，带有标记的实心泥板取代了中空的、封存有陶筹的封球。这些标记自称体系，经发展之后，除了压印的标记，还衍生出用尖锐的笔刻画的、可以识读的符号。这两种从陶筹发展而来的符号均为图画符号——或称“象形符号”。</p>
<p>陶筹系统在数据处理和人类交际史上是个划时代的突破，并最终导致了公元前3300年苏美尔楔形文字的发明。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span>
  </nav>



        </div>
        

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jian Shengnan</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>


  















  

  

</body>
</html>
